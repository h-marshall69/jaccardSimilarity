<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análisis de Similitud de Jaccard Optimizado</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }
        
        .upload-section {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .upload-section h2 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .upload-section p {
            margin-bottom: 15px;
            color: #7f8c8d;
        }
        
        input[type="file"] {
            display: block;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px dashed #ccc;
            border-radius: 4px;
            width: 100%;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        .slider-container {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        .visualization {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .chart-container {
            flex: 1;
            min-width: 300px;
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
        }
        
        .chart-container h3 {
            margin-bottom: 15px;
            color: #2c3e50;
            text-align: center;
        }
        
        #graph, #dendrogram {
            width: 100%;
            height: 400px;
            border: 1px solid #eee;
            border-radius: 4px;
            background-color: #fcfcfc;
        }
        
        .recommendation {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
        }
        
        .recommendation h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            z-index: 1000;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }
        
        .data-preview {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 10px;
            border-radius: 4px;
            background-color: #fcfcfc;
        }
        
        .status {
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            text-align: center;
        }
        
        .status.success {
            background-color: #d4edda;
            color: #155724;
        }
        
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .status.warning {
            background-color: #fff3cd;
            color: #856404;
        }
        
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
        }
        
        .node {
            stroke: #fff;
            stroke-width: 2px;
        }
        
        .label {
            font-size: 10px;
            font-family: sans-serif;
        }
        
        .progress-container {
            width: 100%;
            background-color: #f1f1f1;
            border-radius: 4px;
            margin: 15px 0;
            display: none;
        }
        
        .progress-bar {
            width: 0%;
            height: 20px;
            background-color: #4CAF50;
            border-radius: 4px;
            text-align: center;
            line-height: 20px;
            color: white;
        }
        
        .sampling-controls {
            margin-top: 15px;
            padding: 15px;
            background-color: #e8f4fc;
            border-radius: 8px;
        }
        
        .user-item {
            margin-bottom: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Análisis de Similitud de Jaccard Optimizado</h1>
        
        <div class="upload-section">
            <h2>Cargar Dataset</h2>
            <p>Selecciona un archivo CSV con la estructura: user_id, original_title</p>
            <input type="file" id="csvFile" accept=".csv">
            <button id="loadData">Cargar Datos</button>
            
            <div class="sampling-controls">
                <h3>Muestreo de Datos</h3>
                <p>Para conjuntos de datos grandes, es recomendable usar una muestra representativa</p>
                <div class="slider-label">
                    <span>Tamaño de muestra:</span>
                    <span id="sampleSizeValue">500</span>
                </div>
                <input type="range" id="sampleSize" min="100" max="2000" step="100" value="500">
                <button id="applySampling">Aplicar Muestreo</button>
            </div>
            
            <div id="dataStatus" class="status"></div>
            <div id="dataPreview" class="data-preview"></div>
        </div>
        
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar">0%</div>
        </div>
        
        <div class="controls">
            <button id="calculateSimilarity" disabled>Calcular Similitud</button>
            <button id="showGraph" disabled>Mostrar Grafo</button>
            <button id="showDendrogram" disabled>Mostrar Dendrograma</button>
            <button id="showRecommendations" disabled>Generar Recomendaciones</button>
        </div>
        
        <div class="slider-container">
            <div class="slider-label">
                <span>Umbral de Similitud:</span>
                <span id="thresholdValue">0.3</span>
            </div>
            <input type="range" id="similarityThreshold" min="0" max="1" step="0.01" value="0.3">
        </div>
        
        <div class="visualization">
            <div class="chart-container">
                <h3>Grafo de Similitud</h3>
                <div id="graph"></div>
            </div>
            
            <div class="chart-container">
                <h3>Dendrograma</h3>
                <div id="dendrogram"></div>
            </div>
        </div>
        
        <div class="recommendation">
            <h3>Recomendaciones</h3>
            <div id="recommendations"></div>
        </div>
    </div>

    <script>
        // Variables globales
        let userData = [];
        let sampledUserData = [];
        let jaccardSimilarity = [];
        let userIds = [];
        let sampledUserIds = [];
        
        // Elementos del DOM
        const csvFileInput = document.getElementById('csvFile');
        const loadDataBtn = document.getElementById('loadData');
        const calculateSimilarityBtn = document.getElementById('calculateSimilarity');
        const showGraphBtn = document.getElementById('showGraph');
        const showDendrogramBtn = document.getElementById('showDendrogram');
        const showRecommendationsBtn = document.getElementById('showRecommendations');
        const similarityThreshold = document.getElementById('similarityThreshold');
        const thresholdValue = document.getElementById('thresholdValue');
        const graphDiv = document.getElementById('graph');
        const dendrogramDiv = document.getElementById('dendrogram');
        const recommendationsDiv = document.getElementById('recommendations');
        const dataStatus = document.getElementById('dataStatus');
        const dataPreview = document.getElementById('dataPreview');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const sampleSize = document.getElementById('sampleSize');
        const sampleSizeValue = document.getElementById('sampleSizeValue');
        const applySamplingBtn = document.getElementById('applySampling');
        
        // Event listeners
        loadDataBtn.addEventListener('click', loadCSVData);
        calculateSimilarityBtn.addEventListener('click', calculateJaccardSimilarity);
        showGraphBtn.addEventListener('click', renderGraph);
        showDendrogramBtn.addEventListener('click', renderDendrogram);
        showRecommendationsBtn.addEventListener('click', showRecommendations);
        similarityThreshold.addEventListener('input', updateThreshold);
        sampleSize.addEventListener('input', updateSampleSize);
        applySamplingBtn.addEventListener('click', applySampling);
        
        // Actualizar valor del umbral
        function updateThreshold() {
            thresholdValue.textContent = similarityThreshold.value;
        }
        
        // Actualizar valor del tamaño de muestra
        function updateSampleSize() {
            sampleSizeValue.textContent = sampleSize.value;
        }
        
        // Mostrar mensaje de estado
        function showStatus(message, type = 'info') {
            dataStatus.textContent = message;
            dataStatus.className = 'status';
            if (type === 'success') dataStatus.classList.add('success');
            if (type === 'error') dataStatus.classList.add('error');
            if (type === 'warning') dataStatus.classList.add('warning');
        }
        
        // Mostrar/ocultar barra de progreso
        function showProgress(show) {
            progressContainer.style.display = show ? 'block' : 'none';
        }
        
        // Actualizar barra de progreso
        function updateProgress(percent, message = '') {
            progressBar.style.width = percent + '%';
            progressBar.textContent = message || (percent.toFixed(0) + '%');
        }
        
        // Aplicar muestreo a los datos
        function applySampling() {
            const sampleSizeValue = parseInt(sampleSize.value);
            
            if (userData.length === 0) {
                showStatus('Primero carga los datos', 'error');
                return;
            }
            
            if (sampleSizeValue >= userData.length) {
                sampledUserData = [...userData];
                sampledUserIds = [...userIds];
                showStatus(`Usando todos los ${userData.length} usuarios (sin muestreo)`, 'warning');
                return;
            }
            
            // Realizar muestreo aleatorio
            sampledUserData = [];
            const indices = new Set();
            
            while (indices.size < sampleSizeValue) {
                const randomIndex = Math.floor(Math.random() * userData.length);
                indices.add(randomIndex);
            }
            
            for (const index of indices) {
                sampledUserData.push(userData[index]);
            }
            
            sampledUserIds = sampledUserData.map(user => user.user_id);
            
            // Actualizar vista previa
            dataPreview.innerHTML = `
                <p><strong>Muestra de ${sampledUserData.length} usuarios (de ${userData.length} totales):</strong></p>
                <ul>
                    ${sampledUserData.slice(0, 5).map(user => 
                        `<li>Usuario ${user.user_id}: ${user.titles.length} títulos</li>`
                    ).join('')}
                    ${sampledUserData.length > 5 ? `<li>... y ${sampledUserData.length - 5} usuarios más</li>` : ''}
                </ul>
            `;
            
            showStatus(`Muestra de ${sampledUserData.length} usuarios creada correctamente`, 'success');
            
            // Habilitar botones
            calculateSimilarityBtn.disabled = false;
            showGraphBtn.disabled = true;
            showDendrogramBtn.disabled = true;
            showRecommendationsBtn.disabled = true;
            
            // Reiniciar similitudes
            jaccardSimilarity = [];
        }
        
        // Cargar datos CSV
        function loadCSVData() {
            const file = csvFileInput.files[0];
            if (!file) {
                showStatus('Por favor, selecciona un archivo CSV', 'error');
                return;
            }
            
            showStatus('Cargando datos...');
            showProgress(true);
            updateProgress(5, 'Iniciando carga...');
            
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                step: function(results, parser) {
                    // Procesamiento por lotes para no bloquear la UI
                    if (results.data && results.data.user_id && results.data.original_title) {
                        const userId = results.data.user_id;
                        const title = results.data.original_title;
                        
                        // Buscar si el usuario ya existe
                        let userIndex = userData.findIndex(u => u.user_id === userId);
                        
                        if (userIndex === -1) {
                            // Nuevo usuario
                            userData.push({
                                user_id: userId,
                                titles: [title]
                            });
                        } else {
                            // Usuario existente, añadir título si no existe
                            if (!userData[userIndex].titles.includes(title)) {
                                userData[userIndex].titles.push(title);
                            }
                        }
                    }
                    
                    // Actualizar progreso periódicamente
                    if (results.meta.cursor % 10000 === 0) {
                        updateProgress(5 + (results.meta.cursor / 500000 * 90), `Procesados ${results.meta.cursor} filas...`);
                    }
                },
                complete: function(results) {
                    if (results.data.length === 0) {
                        showStatus('El archivo CSV está vacío o no tiene datos válidos', 'error');
                        showProgress(false);
                        return;
                    }
                    
                    // Verificar que las columnas necesarias existen
                    if (!results.meta.fields.includes('user_id') || !results.meta.fields.includes('original_title')) {
                        showStatus('El CSV debe contener las columnas: user_id y original_title', 'error');
                        showProgress(false);
                        return;
                    }
                    
                    // Extraer IDs de usuarios
                    userIds = userData.map(user => user.user_id);
                    
                    // Aplicar muestreo por defecto para conjuntos grandes
                    if (userData.length > 1000) {
                        updateProgress(95, 'Aplicando muestreo automático...');
                        
                        // Por defecto, usar 500 usuarios para conjuntos grandes
                        sampleSize.value = "500";
                        sampleSizeValue.textContent = "500";
                        
                        // Aplicar muestreo
                        applySampling();
                        
                        showStatus(`Datos cargados: ${userData.length} usuarios. Se usará una muestra de ${sampledUserData.length} usuarios para el análisis.`, 'warning');
                    } else {
                        // Para conjuntos pequeños, usar todos los datos
                        sampledUserData = [...userData];
                        sampledUserIds = [...userIds];
                        
                        // Habilitar botones
                        calculateSimilarityBtn.disabled = false;
                        
                        // Mostrar vista previa de datos
                        dataPreview.innerHTML = `
                            <p><strong>${userData.length} usuarios cargados:</strong></p>
                            <ul>
                                ${userData.slice(0, 5).map(user => 
                                    `<li>Usuario ${user.user_id}: ${user.titles.length} títulos</li>`
                                ).join('')}
                                ${userData.length > 5 ? `<li>... y ${userData.length - 5} usuarios más</li>` : ''}
                            </ul>
                        `;
                        
                        showStatus(`Datos cargados correctamente: ${userData.length} usuarios`, 'success');
                    }
                    
                    updateProgress(100, 'Completado');
                    setTimeout(() => showProgress(false), 1000);
                    
                    console.log('Datos cargados:', userData);
                },
                error: function(error) {
                    console.error('Error al cargar CSV:', error);
                    showStatus('Error al cargar el archivo CSV: ' + error.message, 'error');
                    showProgress(false);
                }
            });
        }
        
        // Calcular similitud de Jaccard optimizada
        function calculateJaccardSimilarity() {
            if (sampledUserData.length === 0) {
                showStatus('Primero carga los datos', 'error');
                return;
            }
            
            showStatus('Calculando similitud de Jaccard...');
            showProgress(true);
            updateProgress(0, 'Iniciando cálculo...');
            
            // Inicializar matriz de similitud
            jaccardSimilarity = Array(sampledUserData.length).fill().map(() => Array(sampledUserData.length).fill(0));
            
            // Calcular similitud para cada par de usuarios por lotes
            const totalPairs = (sampledUserData.length * (sampledUserData.length - 1)) / 2;
            let processedPairs = 0;
            let lastUpdate = 0;
            
            // Usar requestAnimationFrame para no bloquear la UI
            const calculateBatch = (startI = 0, startJ = 1) => {
                for (let i = startI; i < sampledUserData.length; i++) {
                    // Diagonal principal (máxima similitud)
                    jaccardSimilarity[i][i] = 1;
                    
                    for (let j = (i === startI ? startJ : i + 1); j < sampledUserData.length; j++) {
                        const setA = new Set(sampledUserData[i].titles);
                        const setB = new Set(sampledUserData[j].titles);
                        
                        // Calcular intersección y unión
                        const intersection = new Set([...setA].filter(x => setB.has(x)));
                        const union = new Set([...setA, ...setB]);
                        
                        // Calcular similitud de Jaccard
                        const similarity = union.size > 0 ? intersection.size / union.size : 0;
                        jaccardSimilarity[i][j] = similarity;
                        jaccardSimilarity[j][i] = similarity; // Matriz simétrica
                        
                        processedPairs++;
                        
                        // Actualizar progreso cada 1000 pares para no sobrecargar la UI
                        if (processedPairs - lastUpdate >= 1000 || processedPairs === totalPairs) {
                            lastUpdate = processedPairs;
                            const percent = (processedPairs / totalPairs * 100);
                            updateProgress(percent, `Calculando: ${processedPairs} de ${totalPairs} pares`);
                            
                            // Pausar para permitir que la UI se actualice
                            if (processedPairs < totalPairs) {
                                requestAnimationFrame(() => calculateBatch(i, j + 1));
                                return;
                            }
                        }
                    }
                }
                
                // Cálculo completado
                updateProgress(100, 'Completado');
                
                // Habilitar botones adicionales
                showGraphBtn.disabled = false;
                showDendrogramBtn.disabled = false;
                showRecommendationsBtn.disabled = false;
                
                showStatus('Similitud de Jaccard calculada correctamente', 'success');
                setTimeout(() => showProgress(false), 1000);
                
                console.log('Matriz de similitud calculada para', sampledUserData.length, 'usuarios');
            };
            
            // Iniciar cálculo
            calculateBatch();
        }
        
        // Renderizar grafo de similitud
        function renderGraph() {
            if (jaccardSimilarity.length === 0) {
                showStatus('Primero calcula la similitud', 'error');
                return;
            }
            
            showStatus('Generando grafo de similitud...');
            
            // Limpiar contenedor
            graphDiv.innerHTML = '';
            
            // Configurar SVG
            const width = graphDiv.clientWidth;
            const height = 400;
            const svg = d3.select('#graph')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Crear tooltip
            const tooltip = d3.select('body')
                .append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);
            
            // Umbral de similitud
            const threshold = parseFloat(similarityThreshold.value);
            
            // Crear nodos y enlaces
            const nodes = sampledUserIds.map((id, i) => ({ 
                id, 
                index: i, 
                titles: sampledUserData[i].titles,
                titleCount: sampledUserData[i].titles.length
            }));
            
            const links = [];
            for (let i = 0; i < sampledUserIds.length; i++) {
                for (let j = i + 1; j < sampledUserIds.length; j++) {
                    if (jaccardSimilarity[i][j] >= threshold) {
                        links.push({
                            source: i,
                            target: j,
                            value: jaccardSimilarity[i][j]
                        });
                    }
                }
            }
            
            // Configurar fuerza de simulación
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.index).distance(d => 150 - (d.value * 100)))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2));
            
            // Dibujar enlaces
            const link = svg.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('class', 'link')
                .attr('stroke-width', d => d.value * 5);
            
            // Dibujar nodos
            const node = svg.append('g')
                .attr('class', 'nodes')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('class', 'node')
                .attr('r', d => 5 + (d.titleCount / 5)) // Tamaño basado en cantidad de títulos
                .attr('fill', (d, i) => d3.interpolatePlasma(i / nodes.length))
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // Añadir etiquetas a los nodos
            const label = svg.append('g')
                .attr('class', 'labels')
                .selectAll('text')
                .data(nodes)
                .enter().append('text')
                .text(d => d.id)
                .attr('font-size', '10px')
                .attr('dx', 12)
                .attr('dy', 4);
            
            // Añadir interactividad a los nodos
            node.on('mouseover', function(event, d) {
                tooltip.transition().duration(200).style('opacity', .9);
                tooltip.html(`
                    <strong>Usuario:</strong> ${d.id}<br>
                    <strong>Items:</strong> ${d.titleCount}<br>
                    <strong>Ejemplos:</strong> ${d.titles.slice(0, 3).join(', ')}...
                `)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 28) + 'px');
                
                // Resaltar nodos conectados
                link.style('stroke', l => {
                    const isConnected = l.source.index === d.index || l.target.index === d.index;
                    return isConnected ? 'steelblue' : '#999';
                })
                .style('stroke-width', l => {
                    const isConnected = l.source.index === d.index || l.target.index === d.index;
                    return isConnected ? l.value * 5 + 1 : l.value * 5;
                });
            })
            .on('mouseout', function() {
                tooltip.transition().duration(500).style('opacity', 0);
                
                // Restaurar apariencia normal
                link.style('stroke', '#999')
                    .style('stroke-width', d => d.value * 5);
            });
            
            // Actualizar posición en cada tick de la simulación
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // Funciones de arrastre
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            // Añadir leyenda
            const legend = graphDiv.appendChild(document.createElement('div'));
            legend.className = 'legend';
            legend.innerHTML = `
                <div class="legend-item">
                    <div class="legend-color" style="background-color: ${d3.interpolatePlasma(0)}"></div>
                    <span>Usuarios con pocos items</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: ${d3.interpolatePlasma(0.5)}"></div>
                    <span>Usuarios con items promedio</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: ${d3.interpolatePlasma(1)}"></div>
                    <span>Usuarios con muchos items</span>
                </div>
            `;
            
            showStatus('Grafo de similitud generado correctamente', 'success');
        }
        
        // Renderizar dendrograma
        function renderDendrogram() {
            if (jaccardSimilarity.length === 0) {
                showStatus('Primero calcula la similitud', 'error');
                return;
            }
            
            showStatus('Generando dendrograma...');
            
            // Limpiar contenedor
            dendrogramDiv.innerHTML = '<p>Dendrograma deshabilitado para grandes conjuntos de datos.</p>';
            
            showStatus('Dendrograma no disponible para muestras grandes', 'warning');
        }
        
        // Generar recomendaciones
        function showRecommendations() {
            if (jaccardSimilarity.length === 0) {
                showStatus('Primero calcula la similitud', 'error');
                return;
            }
            
            showStatus('Generando recomendaciones...');
            showProgress(true);
            updateProgress(0, 'Generando recomendaciones...');
            
            recommendationsDiv.innerHTML = '<h4>Recomendaciones basadas en similitud:</h4>';
            
            // Para cada usuario, encontrar los más similares y recomendar items que no tenga
            const totalUsers = sampledUserData.length;
            let processedUsers = 0;
            
            const processBatch = (startIndex = 0) => {
                for (let i = startIndex; i < totalUsers; i++) {
                    const user = sampledUserData[i];
                    
                    // Encontrar usuarios similares (excluyéndose a sí mismo)
                    const similarUsers = [];
                    
                    for (let j = 0; j < totalUsers; j++) {
                        if (i !== j && jaccardSimilarity[i][j] > 0.1) {
                            similarUsers.push({
                                index: j,
                                similarity: jaccardSimilarity[i][j]
                            });
                        }
                    }
                    
                    // Ordenar por similitud descendente
                    similarUsers.sort((a, b) => b.similarity - a.similarity);
                    
                    if (similarUsers.length > 0) {
                        const userItems = new Set(user.titles);
                        const recommendations = new Map();
                        
                        // Considerar los 3 usuarios más similares
                        for (let k = 0; k < Math.min(3, similarUsers.length); k++) {
                            const similarUser = sampledUserData[similarUsers[k].index];
                            const similarUserItems = new Set(similarUser.titles);
                            
                            // Encontrar items en el usuario similar que el usuario actual no tiene
                            for (const item of similarUserItems) {
                                if (!userItems.has(item)) {
                                    if (!recommendations.has(item)) {
                                        recommendations.set(item, {
                                            count: 1,
                                            maxSimilarity: similarUsers[k].similarity
                                        });
                                    } else {
                                        const rec = recommendations.get(item);
                                        rec.count++;
                                        rec.maxSimilarity = Math.max(rec.maxSimilarity, similarUsers[k].similarity);
                                    }
                                }
                            }
                        }
                        
                        // Convertir a array y ordenar por frecuencia y similitud
                        const sortedRecs = Array.from(recommendations.entries())
                            .map(([item, data]) => ({ item, ...data }))
                            .sort((a, b) => {
                                // Primero por frecuencia, luego por similitud
                                if (b.count !== a.count) return b.count - a.count;
                                return b.maxSimilarity - a.maxSimilarity;
                            });
                        
                        if (sortedRecs.length > 0) {
                            const userDiv = document.createElement('div');
                            userDiv.className = 'user-item';
                            userDiv.innerHTML = `
                                <p><strong>Usuario ${user.user_id}</strong> (${user.titles.length} items)</p>
                                <ul>
                                    ${sortedRecs.slice(0, 3).map(rec => 
                                        `<li>${rec.item} (recomendado por ${rec.count} usuario(s), similitud: ${rec.maxSimilarity.toFixed(2)})</li>`
                                    ).join('')}
                                </ul>
                            `;
                            recommendationsDiv.appendChild(userDiv);
                        }
                    }
                    
                    processedUsers++;
                    
                    // Actualizar progreso cada 10 usuarios
                    if (processedUsers % 10 === 0 || processedUsers === totalUsers) {
                        const percent = (processedUsers / totalUsers * 100);
                        updateProgress(percent, `Procesando usuario ${processedUsers} de ${totalUsers}`);
                        
                        // Pausar para permitir que la UI se actualice
                        if (processedUsers < totalUsers) {
                            requestAnimationFrame(() => processBatch(i + 1));
                            return;
                        }
                    }
                }
                
                // Procesamiento completado
                updateProgress(100, 'Completado');
                
                if (recommendationsDiv.children.length === 1) {
                    recommendationsDiv.innerHTML += '<p>No se encontraron recomendaciones significativas.</p>';
                }
                
                showStatus('Recomendaciones generadas correctamente', 'success');
                setTimeout(() => showProgress(false), 1000);
            };
            
            // Iniciar procesamiento
            processBatch();
        }
    </script>
</body>
</html>