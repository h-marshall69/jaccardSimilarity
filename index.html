<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análisis de Similitud de Jaccard con Clustering</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        /* Estilos anteriores se mantienen igual */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
        }
        
        h1, h2, h3 {
            color: #2c3e50;
            margin-top: 0;
        }
        
        h1 {
            text-align: center;
            padding-bottom: 15px;
            margin-bottom: 25px;
            border-bottom: 2px solid #eee;
        }
        
        .upload-section, .controls, .visualization, .recommendation {
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 10px;
            background-color: #f9f9f9;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
        }
        
        .sampling-controls {
            margin-top: 15px;
            padding: 15px;
            background-color: #edf2f7;
            border-radius: 8px;
        }
        
        .slider-container {
            margin: 15px 0;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: #e2e8f0;
            border-radius: 5px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #2980b9;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 18px;
            margin: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        button:disabled {
            background-color: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .status {
            padding: 12px;
            margin: 12px 0;
            border-radius: 6px;
            font-weight: 500;
        }
        
        .success {
            background-color: #c6f6d5;
            color: #22543d;
            border: 1px solid #9ae6b4;
        }
        
        .error {
            background-color: #fed7d7;
            color: #742a2a;
            border: 1px solid #feb2b2;
        }
        
        .warning {
            background-color: #feebcb;
            color: #744210;
            border: 1px solid #fbd38d;
        }
        
        .info {
            background-color: #bee3f8;
            color: #2a4365;
            border: 1px solid #90cdf4;
        }
        
        .progress-container {
            width: 100%;
            height: 22px;
            background-color: #edf2f7;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
            display: none;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db 0%, #2980b9 100%);
            text-align: center;
            line-height: 22px;
            color: white;
            font-weight: 600;
            transition: width 0.4s;
        }
        
        .data-preview {
            margin-top: 15px;
            padding: 15px;
            background-color: #edf2f7;
            border-radius: 8px;
            max-height: 220px;
            overflow-y: auto;
            font-size: 14px;
        }
        
        .chart-container {
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 10px;
            background-color: white;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
        }
        
        .chart-container h3 {
            padding-bottom: 12px;
            margin-bottom: 15px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        #graph, #dendrogram {
            width: 100%;
            height: 450px;
            border: 1px solid #e2e8f0;
            background-color: white;
            border-radius: 8px;
        }
        
        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            border-radius: 6px;
            pointer-events: none;
            font-size: 13px;
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-width: 300px;
        }
        
        .node {
            stroke: #fff;
            stroke-width: 2px;
            transition: r 0.3s, fill 0.3s;
        }
        
        .node:hover {
            r: 8;
        }
        
        .link {
            stroke: #a0aec0;
            stroke-opacity: 0.7;
            transition: stroke-opacity 0.3s;
        }
        
        .recommendation-item {
            padding: 15px;
            margin: 10px 0;
            background-color: #edf2f7;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        
        .cluster-info {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }
        
        .cluster-card {
            flex: 1;
            min-width: 200px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .cluster-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .file-input-container {
            position: relative;
            margin-bottom: 15px;
        }
        
        .file-input-container input[type="file"] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-input-label {
            display: inline-block;
            padding: 12px 20px;
            background: #3498db;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s;
        }
        
        .file-input-label:hover {
            background: #2980b9;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .visualization {
                flex-direction: column;
            }
            
            button {
                width: 100%;
                margin: 5px 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Análisis de Similitud de Jaccard con Clustering</h1>
        
        <div class="upload-section">
            <h2>Cargar Dataset</h2>
            <p>Selecciona un archivo CSV con la estructura: user_id, original_title</p>
            
            <div class="file-input-container">
                <label class="file-input-label">Seleccionar archivo CSV</label>
                <input type="file" id="csvFile" accept=".csv">
            </div>
            
            <button id="loadData">Cargar Datos</button>
            
            <div class="sampling-controls">
                <h3>Muestreo de Datos</h3>
                <p>Para conjuntos de datos grandes, es recomendable usar una muestra representativa</p>
                <div class="slider-label">
                    <span>Tamaño de muestra:</span>
                    <span id="sampleSizeValue">500</span>
                </div>
                <input type="range" id="sampleSize" min="100" max="2000" step="100" value="500">
                <button id="applySampling">Aplicar Muestreo</button>
            </div>
            
            <div id="dataStatus" class="status"></div>
            <div id="dataPreview" class="data-preview"></div>
        </div>
        
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar">0%</div>
        </div>
        
        <div class="controls">
            <button id="calculateSimilarity" disabled>Calcular Similitud</button>
            <button id="showGraph" disabled>Mostrar Grafo con Clustering</button>
            <button id="showDendrogram" disabled>Mostrar Dendrograma</button>
            <button id="showRecommendations" disabled>Generar Recomendaciones</button>
        </div>
        
        <div class="visualization">
            <div class="chart-container">
                <h3>Grafo de Similitud con Clustering</h3>
                <div id="graph"></div>
            </div>
            
            <div class="chart-container">
                <h3>Dendrograma con Clustering Jerárquico</h3>
                <div id="dendrogram"></div>
            </div>
        </div>
        
        <div class="recommendation">
            <h3>Recomendaciones Basadas en Clusters</h3>
            <div id="recommendations"></div>
        </div>
    </div>

    <script>
        // Variables globales
        let userData = [];
        let sampledUserData = [];
        let jaccardSimilarity = [];
        let userIds = [];
        let sampledUserIds = [];
        let clusters = [];
        let clusterColors = [];
        let hierarchicalTree = null; // Almacenar el árbol jerárquico completo
        
        // Elementos del DOM
        const csvFileInput = document.getElementById('csvFile');
        const loadDataBtn = document.getElementById('loadData');
        const calculateSimilarityBtn = document.getElementById('calculateSimilarity');
        const showGraphBtn = document.getElementById('showGraph');
        const showDendrogramBtn = document.getElementById('showDendrogram');
        const showRecommendationsBtn = document.getElementById('showRecommendations');
        const graphDiv = document.getElementById('graph');
        const dendrogramDiv = document.getElementById('dendrogram');
        const recommendationsDiv = document.getElementById('recommendations');
        const dataStatus = document.getElementById('dataStatus');
        const dataPreview = document.getElementById('dataPreview');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const sampleSize = document.getElementById('sampleSize');
        const sampleSizeValue = document.getElementById('sampleSizeValue');
        const applySamplingBtn = document.getElementById('applySampling');
        
        // Paleta de colores para clusters
        const colorPalette = [
            '#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6', 
            '#1abc9c', '#d35400', '#c0392b', '#16a085', '#8e44ad',
            '#27ae60', '#f1c40f', '#e67e22', '#7f8c8d', '#2c3e50'
        ];
        
        // Event listeners
        loadDataBtn.addEventListener('click', loadCSVData);
        calculateSimilarityBtn.addEventListener('click', calculateJaccardSimilarity);
        showGraphBtn.addEventListener('click', renderGraphWithClustering);
        showDendrogramBtn.addEventListener('click', renderDendrogram);
        showRecommendationsBtn.addEventListener('click', showRecommendations);
        sampleSize.addEventListener('input', updateSampleSize);
        applySamplingBtn.addEventListener('click', applySampling);
        
        // Actualizar valor del tamaño de muestra
        function updateSampleSize() {
            sampleSizeValue.textContent = sampleSize.value;
        }
        
        // Mostrar mensaje de estado
        function showStatus(message, type = 'info') {
            dataStatus.textContent = message;
            dataStatus.className = 'status';
            if (type === 'success') dataStatus.classList.add('success');
            if (type === 'error') dataStatus.classList.add('error');
            if (type === 'warning') dataStatus.classList.add('warning');
        }
        
        // Mostrar/ocultar barra de progreso
        function showProgress(show) {
            progressContainer.style.display = show ? 'block' : 'none';
        }
        
        // Actualizar barra de progreso
        function updateProgress(percent, message = '') {
            progressBar.style.width = percent + '%';
            progressBar.textContent = message || (percent.toFixed(0) + '%');
        }
        
        // Aplicar muestreo a los datos
        function applySampling() {
            const sampleSizeValue = parseInt(sampleSize.value);
            
            if (userData.length === 0) {
                showStatus('Primero carga los datos', 'error');
                return;
            }
            
            if (sampleSizeValue >= userData.length) {
                sampledUserData = [...userData];
                sampledUserIds = [...userIds];
                showStatus(`Usando todos los ${userData.length} usuarios (sin muestreo)`, 'warning');
                return;
            }
            
            // Realizar muestreo aleatorio
            sampledUserData = [];
            const indices = new Set();
            
            while (indices.size < sampleSizeValue) {
                const randomIndex = Math.floor(Math.random() * userData.length);
                indices.add(randomIndex);
            }
            
            for (const index of indices) {
                sampledUserData.push(userData[index]);
            }
            
            sampledUserIds = sampledUserData.map(user => user.user_id);
            
            // Actualizar vista previa
            dataPreview.innerHTML = `
                <p><strong>Muestra de ${sampledUserData.length} usuarios (de ${userData.length} totales):</strong></p>
                <ul>
                    ${sampledUserData.slice(0, 5).map(user => 
                        `<li>Usuario ${user.user_id}: ${user.titles.length} títulos</li>`
                    ).join('')}
                    ${sampledUserData.length > 5 ? `<li>... y ${sampledUserData.length - 5} usuarios más</li>` : ''}
                </ul>
            `;
            
            showStatus(`Muestra de ${sampledUserData.length} usuarios creada correctamente`, 'success');
            
            // Habilitar botones
            calculateSimilarityBtn.disabled = false;
            showGraphBtn.disabled = true;
            showDendrogramBtn.disabled = true;
            showRecommendationsBtn.disabled = true;
            
            // Reiniciar similitudes
            jaccardSimilarity = [];
            hierarchicalTree = null;
        }
        
        // Cargar datos CSV
        function loadCSVData() {
            const file = csvFileInput.files[0];
            if (!file) {
                showStatus('Por favor, selecciona un archivo CSV', 'error');
                return;
            }
            
            showStatus('Cargando datos...');
            showProgress(true);
            updateProgress(5, 'Iniciando carga...');
            
            // Reiniciar datos
            userData = [];
            
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                step: function(results, parser) {
                    // Procesamiento por lotes para no bloquear la UI
                    if (results.data && results.data.user_id && results.data.original_title) {
                        const userId = results.data.user_id;
                        const title = results.data.original_title;
                        
                        // Buscar si el usuario ya existe
                        let userIndex = userData.findIndex(u => u.user_id === userId);
                        
                        if (userIndex === -1) {
                            // Nuevo usuario
                            userData.push({
                                user_id: userId,
                                titles: [title]
                            });
                        } else {
                            // Usuario existente, añadir título si no existe
                            if (!userData[userIndex].titles.includes(title)) {
                                userData[userIndex].titles.push(title);
                            }
                        }
                    }
                    
                    // Actualizar progreso periódicamente
                    if (results.meta.cursor % 10000 === 0) {
                        updateProgress(5 + (results.meta.cursor / 500000 * 90), `Procesados ${results.meta.cursor} filas...`);
                    }
                },
                complete: function(results) {
                    if (results.data.length === 0) {
                        showStatus('El archivo CSV está vacío o no tiene datos válidos', 'error');
                        showProgress(false);
                        return;
                    }
                    
                    // Verificar que las columnas necesarias existen
                    if (!results.meta.fields || (!results.meta.fields.includes('user_id') || !results.meta.fields.includes('original_title'))) {
                        showStatus('El CSV debe contener las columnas: user_id y original_title', 'error');
                        showProgress(false);
                        return;
                    }
                    
                    // Extraer IDs de usuarios
                    userIds = userData.map(user => user.user_id);
                    
                    // Aplicar muestreo por defecto para conjuntos grandes
                    if (userData.length > 1000) {
                        updateProgress(95, 'Aplicando muestreo automático...');
                        
                        // Por defecto, usar 500 usuarios para conjuntos grandes
                        sampleSize.value = "500";
                        sampleSizeValue.textContent = "500";
                        
                        // Aplicar muestreo
                        applySampling();
                        
                        showStatus(`Datos cargados: ${userData.length} usuarios. Se usará una muestra de ${sampledUserData.length} usuarios para el análisis.`, 'warning');
                    } else {
                        // Para conjuntos pequeños, usar todos los datos
                        sampledUserData = [...userData];
                        sampledUserIds = [...userIds];
                        
                        // Habilitar botones
                        calculateSimilarityBtn.disabled = false;
                        
                        // Mostrar vista previa de datos
                        dataPreview.innerHTML = `
                            <p><strong>${userData.length} usuarios cargados:</strong></p>
                            <ul>
                                ${userData.slice(0, 5).map(user => 
                                    `<li>Usuario ${user.user_id}: ${user.titles.length} títulos</li>`
                                ).join('')}
                                ${userData.length > 5 ? `<li>... y ${userData.length - 5} usuarios más</li>` : ''}
                            </ul>
                        `;
                        
                        showStatus(`Datos cargados correctamente: ${userData.length} usuarios`, 'success');
                    }
                    
                    updateProgress(100, 'Completado');
                    setTimeout(() => showProgress(false), 1000);
                    
                    console.log('Datos cargados:', userData);
                },
                error: function(error) {
                    console.error('Error al cargar CSV:', error);
                    showStatus('Error al cargar el archivo CSV: ' + error.message, 'error');
                    showProgress(false);
                }
            });
        }
        
        // Calcular similitud de Jaccard optimizada
        function calculateJaccardSimilarity() {
            if (sampledUserData.length === 0) {
                showStatus('Primero carga los datos', 'error');
                return;
            }
            
            showStatus('Calculando similitud de Jaccard...');
            showProgress(true);
            updateProgress(0, 'Iniciando cálculo...');
            
            // Inicializar matriz de similitud
            jaccardSimilarity = Array(sampledUserData.length).fill().map(() => Array(sampledUserData.length).fill(0));
            
            // Calcular similitud para cada par de usuarios por lotes
            const totalPairs = (sampledUserData.length * (sampledUserData.length - 1)) / 2;
            let processedPairs = 0;
            let lastUpdate = 0;
            
            // Usar requestAnimationFrame para no bloquear la UI
            const calculateBatch = (startI = 0, startJ = 1) => {
                for (let i = startI; i < sampledUserData.length; i++) {
                    // Diagonal principal (máxima similitud)
                    jaccardSimilarity[i][i] = 1;
                    
                    for (let j = (i === startI ? startJ : i + 1); j < sampledUserData.length; j++) {
                        const setA = new Set(sampledUserData[i].titles);
                        const setB = new Set(sampledUserData[j].titles);
                        
                        // Calcular intersección y unión
                        const intersection = new Set([...setA].filter(x => setB.has(x)));
                        const union = new Set([...setA, ...setB]);
                        
                        // Calcular similitud de Jaccard
                        const similarity = union.size > 0 ? intersection.size / union.size : 0;
                        jaccardSimilarity[i][j] = similarity;
                        jaccardSimilarity[j][i] = similarity; // Matriz simétrica
                        
                        processedPairs++;
                        
                        // Actualizar progreso cada 1000 pares para no sobrecargar la UI
                        if (processedPairs - lastUpdate >= 1000 || processedPairs === totalPairs) {
                            lastUpdate = processedPairs;
                            const percent = (processedPairs / totalPairs * 100);
                            updateProgress(percent, `Calculando: ${processedPairs} de ${totalPairs} pares`);
                            
                            // Pausar para permitir que la UI se actualice
                            if (processedPairs < totalPairs) {
                                requestAnimationFrame(() => calculateBatch(i, j + 1));
                                return;
                            }
                        }
                    }
                }
                
                // Cálculo completado
                updateProgress(100, 'Completado');
                
                // Realizar clustering
                performClustering();
                
                // Habilitar botones adicionales
                showGraphBtn.disabled = false;
                showDendrogramBtn.disabled = false;
                showRecommendationsBtn.disabled = false;
                
                showStatus('Similitud de Jaccard calculada correctamente. Clustering aplicado.', 'success');
                setTimeout(() => showProgress(false), 1000);
                
                console.log('Matriz de similitud calculada para', sampledUserData.length, 'usuarios');
            };
            
            // Iniciar cálculo
            calculateBatch();
        }
        
        // Realizar clustering basado en la similitud
        function performClustering() {
            // Convertir similitud a distancia (1 - similitud)
            const distanceMatrix = jaccardSimilarity.map(row => 
                row.map(similarity => 1 - similarity)
            );
            
            // Aplicar clustering jerárquico aglomerativo
            clusters = hierarchicalClustering(distanceMatrix, 5); // 5 clusters
            
            // Construir árbol jerárquico completo para el dendrograma
            hierarchicalTree = buildHierarchicalTree(distanceMatrix, sampledUserIds);
            
            // Asignar colores a los clusters
            clusterColors = [];
            for (let i = 0; i < clusters.length; i++) {
                clusterColors.push(colorPalette[i % colorPalette.length]);
            }
            
            console.log('Clusters generados:', clusters);
            console.log('Árbol jerárquico:', hierarchicalTree);
        }
        
        // Algoritmo de clustering jerárquico aglomerativo
        function hierarchicalClustering(distanceMatrix, numClusters) {
            // Inicializar clusters (cada usuario es su propio cluster)
            let clusters = [];
            for (let i = 0; i < distanceMatrix.length; i++) {
                clusters.push([i]);
            }
            
            // Matriz de distancias entre clusters
            let clusterDistances = distanceMatrix.map(row => [...row]);
            
            // Continuar fusionando clusters hasta alcanzar el número deseado
            while (clusters.length > numClusters) {
                // Encontrar los dos clusters más cercanos
                let minDistance = Infinity;
                let clusterA = -1;
                let clusterB = -1;
                
                for (let i = 0; i < clusters.length; i++) {
                    for (let j = i + 1; j < clusters.length; j++) {
                        // Calcular distancia promedio entre clusters (enlace completo)
                        let maxDist = 0;
                        for (const itemA of clusters[i]) {
                            for (const itemB of clusters[j]) {
                                if (distanceMatrix[itemA][itemB] > maxDist) {
                                    maxDist = distanceMatrix[itemA][itemB];
                                }
                            }
                        }
                        
                        if (maxDist < minDistance) {
                            minDistance = maxDist;
                            clusterA = i;
                            clusterB = j;
                        }
                    }
                }
                
                // Fusionar los dos clusters más cercanos
                if (clusterA !== -1 && clusterB !== -1) {
                    clusters[clusterA] = clusters[clusterA].concat(clusters[clusterB]);
                    clusters.splice(clusterB, 1);
                }
            }
            
            return clusters;
        }
        
        // Construir árbol jerárquico completo para dendrograma
        function buildHierarchicalTree(distanceMatrix, labels) {
            // Inicializar clusters (cada usuario es su propio cluster)
            let clusters = [];
            for (let i = 0; i < distanceMatrix.length; i++) {
                clusters.push({
                    id: labels[i],
                    index: i,
                    height: 0,
                    size: 1,
                    children: null
                });
            }
            
            // Historial de fusiones
            const merges = [];
            
            // Continuar fusionando hasta que quede un solo cluster
            while (clusters.length > 1) {
                // Encontrar los dos clusters más cercanos
                let minDistance = Infinity;
                let clusterA = -1;
                let clusterB = -1;
                
                for (let i = 0; i < clusters.length; i++) {
                    for (let j = i + 1; j < clusters.length; j++) {
                        // Calcular distancia máxima entre clusters (enlace completo)
                        let maxDist = 0;
                        const indicesA = getLeafIndices(clusters[i]);
                        const indicesB = getLeafIndices(clusters[j]);
                        
                        for (const idxA of indicesA) {
                            for (const idxB of indicesB) {
                                if (distanceMatrix[idxA][idxB] > maxDist) {
                                    maxDist = distanceMatrix[idxA][idxB];
                                }
                            }
                        }
                        
                        if (maxDist < minDistance) {
                            minDistance = maxDist;
                            clusterA = i;
                            clusterB = j;
                        }
                    }
                }
                
                // Fusionar los dos clusters más cercanos
                if (clusterA !== -1 && clusterB !== -1) {
                    const newCluster = {
                        id: null,
                        index: -1,
                        height: minDistance,
                        size: clusters[clusterA].size + clusters[clusterB].size,
                        children: [clusters[clusterA], clusters[clusterB]]
                    };
                    
                    // Guardar información de la fusión
                    merges.push({
                        source: clusters[clusterA],
                        target: clusters[clusterB],
                        distance: minDistance
                    });
                    
                    // Reemplazar clusters fusionados por el nuevo cluster
                    clusters.splice(clusterB, 1);
                    clusters.splice(clusterA, 1, newCluster);
                }
            }
            
            return clusters[0]; // Devolver el árbol completo
        }
        
        // Obtener todos los índices de hojas en un cluster
        function getLeafIndices(cluster) {
            if (!cluster.children) {
                return [cluster.index];
            }
            
            let indices = [];
            for (const child of cluster.children) {
                indices = indices.concat(getLeafIndices(child));
            }
            return indices;
        }
        
        // Renderizar grafo con clustering
        function renderGraphWithClustering() {
            if (jaccardSimilarity.length === 0 || clusters.length === 0) {
                showStatus('Primero calcula la similitud y clustering', 'error');
                return;
            }
            
            showStatus('Generando grafo con clustering...');
            
            // Limpiar contenedor
            graphDiv.innerHTML = '';
            
            // Configurar SVG
            const width = graphDiv.clientWidth;
            const height = 450;
            const svg = d3.select('#graph')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Crear tooltip
            const tooltip = d3.select('body')
                .append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);
            
            // Crear nodos y enlaces
            const nodes = sampledUserIds.map((id, i) => {
                // Encontrar el cluster al que pertenece este nodo
                let clusterIndex = -1;
                for (let j = 0; j < clusters.length; j++) {
                    if (clusters[j].includes(i)) {
                        clusterIndex = j;
                        break;
                    }
                }
                
                return { 
                    id, 
                    index: i, 
                    titles: sampledUserData[i].titles,
                    titleCount: sampledUserData[i].titles.length,
                    cluster: clusterIndex,
                    color: clusterIndex >= 0 ? clusterColors[clusterIndex] : '#ccc'
                };
            });
            
            // Crear enlaces basados en similitud (sin umbral)
            const links = [];
            for (let i = 0; i < sampledUserIds.length; i++) {
                for (let j = i + 1; j < sampledUserIds.length; j++) {
                    // Incluir todos los enlaces pero con opacidad basada en similitud
                    links.push({
                        source: i,
                        target: j,
                        value: jaccardSimilarity[i][j],
                        opacity: jaccardSimilarity[i][j] * 0.7 // Mayor similitud = mayor opacidad
                    });
                }
            }
            
            // Configurar fuerza de simulación
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.index).distance(d => 200 - (d.value * 150)))
                .force('charge', d3.forceManyBody().strength(-50))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(10));
            
            // Dibujar enlaces
            const link = svg.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('class', 'link')
                .attr('stroke-width', d => d.value * 3)
                .attr('stroke-opacity', d => d.opacity);
            
            // Dibujar nodos
            const node = svg.append('g')
                .attr('class', 'nodes')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('class', 'node')
                .attr('r', d => 5 + (d.titleCount / 3))
                .attr('fill', d => d.color)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // Añadir etiquetas a los nodos
            const label = svg.append('g')
                .attr('class', 'labels')
                .selectAll('text')
                .data(nodes)
                .enter().append('text')
                .text(d => d.id)
                .attr('font-size', '10px')
                .attr('dx', 12)
                .attr('dy', 4);
            
            // Añadir interactividad a los nodos
            node.on('mouseover', function(event, d) {
                // Resaltar nodo
                d3.select(this).attr('stroke', '#2c3e50').attr('stroke-width', 2);
                
                // Resaltar enlaces conectados
                link.attr('stroke', l => 
                    (l.source.index === d.index || l.target.index === d.index) ? '#e74c3c' : '#a0aec0'
                ).attr('stroke-width', l => 
                    (l.source.index === d.index || l.target.index === d.index) ? l.value * 5 : l.value * 3
                );
                
                // Mostrar tooltip
                tooltip.style('opacity', 1)
                    .html(`Usuario: ${d.id}<br>Cluster: ${d.cluster + 1}<br>Títulos: ${d.titleCount}<br>Conectado a: ${links.filter(l => l.source.index === d.index || l.target.index === d.index).length} nodos`)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 25) + 'px');
            })
            .on('mouseout', function(event, d) {
                // Restaurar nodo
                d3.select(this).attr('stroke', null);
                
                // Restaurar enlaces
                link.attr('stroke', '#a0aec0')
                    .attr('stroke-width', d => d.value * 3);
                
                // Ocultar tooltip
                tooltip.style('opacity', 0);
            });
            
            // Actualizar posición en cada tick de la simulación
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // Funciones de arrastre
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            // Mostrar información de clusters
            const clusterInfo = document.createElement('div');
            clusterInfo.className = 'cluster-info';
            clusterInfo.innerHTML = '<h4>Clusters Identificados:</h4>';
            
            for (let i = 0; i < clusters.length; i++) {
                const clusterDiv = document.createElement('div');
                clusterDiv.className = 'cluster-card';
                clusterDiv.innerHTML = `
                    <div><span class="cluster-color" style="background:${clusterColors[i]}"></span> Cluster ${i+1}</div>
                    <div>Usuarios: ${clusters[i].length}</div>
                `;
                clusterInfo.appendChild(clusterDiv);
            }
            
            graphDiv.appendChild(clusterInfo);
            
            showStatus('Grafo con clustering generado correctamente', 'success');
        }
        
        // Renderizar dendrograma
        function renderDendrogram() {
            if (!hierarchicalTree) {
                showStatus('Primero calcula la similitud y clustering', 'error');
                return;
            }
            
            showStatus('Generando dendrograma...');
            
            // Limpiar contenedor
            dendrogramDiv.innerHTML = '';
            
            // Configurar dimensiones
            const margin = { top: 20, right: 90, bottom: 30, left: 90 };
            const width = dendrogramDiv.clientWidth - margin.left - margin.right;
            const height = 450 - margin.top - margin.bottom;
            
            // Configurar layout del dendrograma
            const cluster = d3.cluster()
                .size([height, width]);
            
            // Asignar el árbol al layout
            const root = d3.hierarchy(hierarchicalTree);
            cluster(root);
            
            // Configurar SVG
            const svg = d3.select('#dendrogram')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Dibujar enlaces
            svg.selectAll('.link')
                .data(root.links())
                .enter().append('path')
                .attr('class', 'link')
                .attr('d', d3.linkVertical()
                    .x(d => d.x)
                    .y(d => d.y))
                .style('fill', 'none')
                .style('stroke', '#ccc')
                .style('stroke-width', '1.5px');
            
            // Dibujar nodos
            const node = svg.selectAll('.node')
                .data(root.descendants())
                .enter().append('g')
                .attr('class', d => 'node' + (d.children ? ' node--internal' : ' node--leaf'))
                .attr('transform', d => `translate(${d.x},${d.y})`);
            
            // Añadir círculos a los nodos
            node.append('circle')
                .attr('r', 4.5)
                .style('fill', d => d.children ? '#555' : '#999');
            
            // Añadir etiquetas para nodos hoja
            node.filter(d => !d.children).append('text')
                .attr('dy', '0.31em')
                .attr('x', d => d.x < width / 2 ? 6 : -6)
                .attr('text-anchor', d => d.x < width / 2 ? 'start' : 'end')
                .attr('transform', d => d.x < width / 2 ? null : 'rotate(180)')
                .text(d => d.data.id)
                .style('font-size', '10px')
                .style('fill', '#333');
            
            // Añadir etiquetas para nodos internos
            node.filter(d => d.children).append('text')
                .attr('dy', '0.31em')
                .attr('y', -10)
                .attr('text-anchor', 'middle')
                .text(d => d.data.height.toFixed(2))
                .style('font-size', '9px')
                .style('fill', '#777');
            
            // Añadir tooltip para nodos
            const tooltip = d3.select('body')
                .append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);
            
            node.on('mouseover', function(event, d) {
                let content = '';
                if (d.children) {
                    content = `Nodo interno<br>Altura: ${d.data.height.toFixed(2)}<br>Elementos: ${d.data.size}`;
                } else {
                    content = `Usuario: ${d.data.id}<br>Altura: 0`;
                }
                
                tooltip.style('opacity', 1)
                    .html(content)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 25) + 'px');
            })
            .on('mouseout', function() {
                tooltip.style('opacity', 0);
            });
            
            showStatus('Dendrograma generado correctamente', 'success');
        }
        
        // Mostrar recomendaciones basadas en clusters
        function showRecommendations() {
            if (jaccardSimilarity.length === 0 || clusters.length === 0) {
                showStatus('Primero calcula la similitud y clustering', 'error');
                return;
            }
            
            showStatus('Generando recomendaciones basadas en clusters...');
            
            // Limpiar contenedor
            recommendationsDiv.innerHTML = '';
            
            // Para cada cluster, encontrar títulos populares
            for (let i = 0; i < clusters.length; i++) {
                const cluster = clusters[i];
                
                // Contar frecuencia de títulos en el cluster
                const titleCounts = {};
                for (const userIndex of cluster) {
                    for (const title of sampledUserData[userIndex].titles) {
                        titleCounts[title] = (titleCounts[title] || 0) + 1;
                    }
                }
                
                // Ordenar títulos por frecuencia
                const popularTitles = Object.entries(titleCounts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5) // Top 5 títulos
                    .map(([title, count]) => ({ title, count }));
                
                // Añadir al DOM
                const clusterDiv = document.createElement('div');
                clusterDiv.className = 'recommendation-item';
                clusterDiv.innerHTML = `
                    <h4><span class="cluster-color" style="background:${clusterColors[i]}"></span> Cluster ${i+1} (${cluster.length} usuarios)</h4>
                    <p>Títulos más populares:</p>
                    <ul>
                        ${popularTitles.map(t => `<li>${t.title} (${t.count} usuarios)</li>`).join('')}
                    </ul>
                `;
                recommendationsDiv.appendChild(clusterDiv);
            }
            
            showStatus('Recomendaciones generadas correctamente', 'success');
        }
    </script>
</body>
</html>
