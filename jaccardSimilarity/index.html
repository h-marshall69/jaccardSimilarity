<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análisis de Similitud de Jaccard con Clustering</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        /* Estilos se mantienen igual */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
        }
        
        h1, h2, h3 {
            color: #2c3e50;
            margin-top: 0;
        }
        
        h1 {
            text-align: center;
            padding-bottom: 15px;
            margin-bottom: 25px;
            border-bottom: 2px solid #eee;
        }
        
        .upload-section, .controls, .visualization, .recommendation {
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 10px;
            background-color: #f9f9f9;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
        }
        
        .sampling-controls {
            margin-top: 15px;
            padding: 15px;
            background-color: #edf2f7;
            border-radius: 8px;
        }
        
        .slider-container {
            margin: 15px 0;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: #e2e8f0;
            border-radius: 5px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #2980b9;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 18px;
            margin: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        button:disabled {
            background-color: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .status {
            padding: 12px;
            margin: 12px 0;
            border-radius: 6px;
            font-weight: 500;
        }
        
        .success {
            background-color: #c6f6d5;
            color: #22543d;
            border: 1px solid #9ae6b4;
        }
        
        .error {
            background-color: #fed7d7;
            color: #742a2a;
            border: 1px solid #feb2b2;
        }
        
        .warning {
            background-color: #feebcb;
            color: #744210;
            border: 1px solid #fbd38d;
        }
        
        .info {
            background-color: #bee3f8;
            color: #2a4365;
            border: 1px solid #90cdf4;
        }
        
        .progress-container {
            width: 100%;
            height: 22px;
            background-color: #edf2f7;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
            display: none;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db 0%, #2980b9 100%);
            text-align: center;
            line-height: 22px;
            color: white;
            font-weight: 600;
            transition: width 0.4s;
        }
        
        .data-preview {
            margin-top: 15px;
            padding: 15px;
            background-color: #edf2f7;
            border-radius: 8px;
            max-height: 220px;
            overflow-y: auto;
            font-size: 14px;
        }
        
        .chart-container {
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 10px;
            background-color: white;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
        }
        
        .chart-container h3 {
            padding-bottom: 12px;
            margin-bottom: 15px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        #graph, #dendrogram {
            width: 100%;
            height: 450px;
            border: 1px solid #e2e8f0;
            background-color: white;
            border-radius: 8px;
        }
        
        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            border-radius: 6px;
            pointer-events: none;
            font-size: 13px;
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-width: 300px;
        }
        
        .node {
            stroke: #fff;
            stroke-width: 2px;
            transition: r 0.3s, fill 0.3s;
        }
        
        .node:hover {
            r: 8;
        }
        
        .link {
            stroke: #a0aec0;
            stroke-opacity: 0.7;
            transition: stroke-opacity 0.3s;
        }
        
        .recommendation-item {
            padding: 15px;
            margin: 10px 0;
            background-color: #edf2f7;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        
        .cluster-info {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }
        
        .cluster-card {
            flex: 1;
            min-width: 200px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .cluster-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .file-input-container {
            position: relative;
            margin-bottom: 15px;
        }
        
        .file-input-container input[type="file"] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-input-label {
            display: inline-block;
            padding: 12px 20px;
            background: #3498db;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s;
        }
        
        .file-input-label:hover {
            background: #2980b9;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .visualization {
                flex-direction: column;
            }
            
            button {
                width: 100%;
                margin: 5px 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Análisis de Similitud de Jaccard con Clustering</h1>
        
        <div class="upload-section">
            <h2>Cargar Dataset</h2>
            <p>Selecciona un archivo CSV con la estructura: user_id, original_title</p>
            
            <div class="file-input-container">
                <label class="file-input-label">Seleccionar archivo CSV</label>
                <input type="file" id="csvFile" accept=".csv">
            </div>
            
            <button id="loadData">Cargar Datos</button>
            
            <div class="sampling-controls">
                <h3>Muestreo de Datos</h3>
                <p>Para conjuntos de datos grandes, es recomendable usar una muestra representativa</p>
                <div class="slider-label">
                    <span>Tamaño de muestra:</span>
                    <span id="sampleSizeValue">500</span>
                </div>
                <input type="range" id="sampleSize" min="100" max="2000" step="100" value="500">
                <button id="applySampling">Aplicar Muestreo</button>
            </div>
            
            <div class="similarity-controls">
                <h3>Umbral de Similitud</h3>
                <p>Filtrar conexiones con baja similitud para mejorar el rendimiento</p>
                <div class="slider-label">
                    <span>Umbral mínimo de similitud:</span>
                    <span id="similarityThresholdValue">0.3</span>
                </div>
                <input type="range" id="similarityThreshold" min="0" max="1" step="0.05" value="0.3">
            </div>
            
            <div id="dataStatus" class="status"></div>
            <div id="dataPreview" class="data-preview"></div>
        </div>
        
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar">0%</div>
        </div>
        
        <div class="controls">
            <button id="calculateSimilarity" disabled>Calcular Similitud</button>
            <button id="showGraph" disabled>Mostrar Grafo con Clustering</button>
            <button id="showDendrogram" disabled>Mostrar Dendrograma</button>
            <button id="showRecommendations" disabled>Generar Recomendaciones</button>
        </div>
        
        <div class="visualization">
            <div class="chart-container">
                <h3>Grafo de Similitud con Clustering</h3>
                <div id="graph"></div>
            </div>
            
            <div class="chart-container">
                <h3>Dendrograma con Clustering Jerárquico</h3>
                <div id="dendrogram"></div>
            </div>
        </div>
        
        <div class="recommendation">
            <h3>Recomendaciones Basadas en Clusters</h3>
            <div id="recommendations"></div>
        </div>
    </div>

    <script>
        // Variables globales
        let userData = [];
        let sampledUserData = [];
        let jaccardSimilarity = [];
        let userIds = [];
        let sampledUserIds = [];
        let clusters = [];
        let clusterColors = [];
        let hierarchicalTree = null;
        let similarityThreshold = 0.3; // Umbral mínimo de similitud
        
        // Elementos del DOM
        const csvFileInput = document.getElementById('csvFile');
        const loadDataBtn = document.getElementById('loadData');
        const calculateSimilarityBtn = document.getElementById('calculateSimilarity');
        const showGraphBtn = document.getElementById('showGraph');
        const showDendrogramBtn = document.getElementById('showDendrogram');
        const showRecommendationsBtn = document.getElementById('showRecommendations');
        const graphDiv = document.getElementById('graph');
        const dendrogramDiv = document.getElementById('dendrogram');
        const recommendationsDiv = document.getElementById('recommendations');
        const dataStatus = document.getElementById('dataStatus');
        const dataPreview = document.getElementById('dataPreview');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const sampleSize = document.getElementById('sampleSize');
        const sampleSizeValue = document.getElementById('sampleSizeValue');
        const applySamplingBtn = document.getElementById('applySampling');
        const similarityThresholdSlider = document.getElementById('similarityThreshold');
        const similarityThresholdValue = document.getElementById('similarityThresholdValue');
        
        // Paleta de colores para clusters
        const colorPalette = [
            '#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6', 
            '#1abc9c', '#d35400', '#c0392b', '#16a085', '#8e44ad',
            '#27ae60', '#f1c40f', '#e67e22', '#7f8c8d', '#2c3e50'
        ];
        
        // Event listeners
        loadDataBtn.addEventListener('click', loadCSVData);
        calculateSimilarityBtn.addEventListener('click', calculateJaccardSimilarity);
        showGraphBtn.addEventListener('click', renderGraphWithClustering);
        showDendrogramBtn.addEventListener('click', renderDendrogram);
        showRecommendationsBtn.addEventListener('click', showRecommendations);
        sampleSize.addEventListener('input', updateSampleSize);
        applySamplingBtn.addEventListener('click', applySampling);
        similarityThresholdSlider.addEventListener('input', updateSimilarityThreshold);
        
        // Actualizar valor del tamaño de muestra
        function updateSampleSize() {
            sampleSizeValue.textContent = sampleSize.value;
        }
        
        // Actualizar umbral de similitud
        function updateSimilarityThreshold() {
            similarityThreshold = parseFloat(similarityThresholdSlider.value);
            similarityThresholdValue.textContent = similarityThreshold.toFixed(2);
        }
        
        // Mostrar mensaje de estado
        function showStatus(message, type = 'info') {
            dataStatus.textContent = message;
            dataStatus.className = 'status';
            if (type === 'success') dataStatus.classList.add('success');
            if (type === 'error') dataStatus.classList.add('error');
            if (type === 'warning') dataStatus.classList.add('warning');
        }
        
        // Mostrar/ocultar barra de progreso
        function showProgress(show) {
            progressContainer.style.display = show ? 'block' : 'none';
        }
        
        // Actualizar barra de progreso
        function updateProgress(percent, message = '') {
            progressBar.style.width = percent + '%';
            progressBar.textContent = message || (percent.toFixed(0) + '%');
        }
        
        // Aplicar muestreo a los datos
        function applySampling() {
            const sampleSizeValue = parseInt(sampleSize.value);
            
            if (userData.length === 0) {
                showStatus('Primero carga los datos', 'error');
                return;
            }
            
            if (sampleSizeValue >= userData.length) {
                sampledUserData = [...userData];
                sampledUserIds = [...userIds];
                showStatus(`Usando todos los ${userData.length} usuarios (sin muestreo)`, 'warning');
                return;
            }
            
            // Realizar muestreo aleatorio
            sampledUserData = [];
            const indices = new Set();
            
            while (indices.size < sampleSizeValue) {
                const randomIndex = Math.floor(Math.random() * userData.length);
                indices.add(randomIndex);
            }
            
            for (const index of indices) {
                sampledUserData.push(userData[index]);
            }
            
            sampledUserIds = sampledUserData.map(user => user.user_id);
            
            // Actualizar vista previa
            dataPreview.innerHTML = `
                <p><strong>Muestra de ${sampledUserData.length} usuarios (de ${userData.length} totales):</strong></p>
                <ul>
                    ${sampledUserData.slice(0, 5).map(user => 
                        `<li>Usuario ${user.user_id}: ${user.titles.length} títulos</li>`
                    ).join('')}
                    ${sampledUserData.length > 5 ? `<li>... y ${sampledUserData.length - 5} usuarios más</li>` : ''}
                </ul>
            `;
            
            showStatus(`Muestra de ${sampledUserData.length} usuarios creada correctamente`, 'success');
            
            // Habilitar botones
            calculateSimilarityBtn.disabled = false;
            showGraphBtn.disabled = true;
            showDendrogramBtn.disabled = true;
            showRecommendationsBtn.disabled = true;
            
            // Reiniciar similitudes
            jaccardSimilarity = [];
            hierarchicalTree = null;
        }
        
        // Cargar datos CSV
        function loadCSVData() {
            const file = csvFileInput.files[0];
            if (!file) {
                showStatus('Por favor, selecciona un archivo CSV', 'error');
                return;
            }
            
            showStatus('Cargando datos...');
            showProgress(true);
            updateProgress(5, 'Iniciando carga...');
            
            // Reiniciar datos
            userData = [];
            
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                step: function(results, parser) {
                    // Procesamiento por lotes para no bloquear la UI
                    if (results.data && results.data.user_id && results.data.original_title) {
                        const userId = results.data.user_id;
                        const title = results.data.original_title;
                        
                        // Buscar si el usuario ya existe
                        let userIndex = userData.findIndex(u => u.user_id === userId);
                        
                        if (userIndex === -1) {
                            // Nuevo usuario
                            userData.push({
                                user_id: userId,
                                titles: [title]
                            });
                        } else {
                            // Usuario existente, añadir título si no existe
                            if (!userData[userIndex].titles.includes(title)) {
                                userData[userIndex].titles.push(title);
                            }
                        }
                    }
                    
                    // Actualizar progreso periódicamente
                    if (results.meta.cursor % 10000 === 0) {
                        updateProgress(5 + (results.meta.cursor / 500000 * 90), `Procesados ${results.meta.cursor} filas...`);
                    }
                },
                complete: function(results) {
                    // Verificar que se procesaron datos
                    if (userData.length === 0) {
                        showStatus('El archivo CSV está vacío o no tiene datos válidos', 'error');
                        showProgress(false);
                        return;
                    }
                    
                    // Verificar que las columnas necesarias existen
                    if (!results.meta.fields || (!results.meta.fields.includes('user_id') || !results.meta.fields.includes('original_title'))) {
                        showStatus('El CSV debe contener las columnas: user_id y original_title', 'error');
                        showProgress(false);
                        return;
                    }
                    
                    // Extraer IDs de usuarios
                    userIds = userData.map(user => user.user_id);
                    
                    // Aplicar muestreo por defecto para conjuntos grandes
                    if (userData.length > 1000) {
                        updateProgress(95, 'Aplicando muestreo automático...');
                        
                        // Por defecto, usar 500 usuarios para conjuntos grandes
                        sampleSize.value = "500";
                        sampleSizeValue.textContent = "500";
                        
                        // Aplicar muestreo
                        applySampling();
                        
                        showStatus(`Datos cargados: ${userData.length} usuarios. Se usará una muestra de ${sampledUserData.length} usuarios para el análisis.`, 'warning');
                    } else {
                        // Para conjuntos pequeños, usar todos los datos
                        sampledUserData = [...userData];
                        sampledUserIds = [...userIds];
                        
                        // Habilitar botones
                        calculateSimilarityBtn.disabled = false;
                        
                        // Mostrar vista previa de datos
                        dataPreview.innerHTML = `
                            <p><strong>${userData.length} usuarios cargados:</strong></p>
                            <ul>
                                ${userData.slice(0, 5).map(user => 
                                    `<li>Usuario ${user.user_id}: ${user.titles.length} títulos</li>`
                                ).join('')}
                                ${userData.length > 5 ? `<li>... y ${userData.length - 5} usuarios más</li>` : ''}
                            </ul>
                        `;
                        
                        showStatus(`Datos cargados correctamente: ${userData.length} usuarios`, 'success');
                    }
                    
                    updateProgress(100, 'Completado');
                    setTimeout(() => showProgress(false), 1000);
                    
                    console.log('Datos cargados:', userData);
                },
                error: function(error) {
                    console.error('Error al cargar CSV:', error);
                    showStatus('Error al cargar el archivo CSV: ' + error.message, 'error');
                    showProgress(false);
                }
            });
        }
        
        // Calcular similitud de Jaccard optimizada
        function calculateJaccardSimilarity() {
            if (sampledUserData.length === 0) {
                showStatus('Primero carga los datos', 'error');
                return;
            }
            
            showStatus('Calculando similitud de Jaccard...');
            showProgress(true);
            updateProgress(0, 'Iniciando cálculo...');
            
            // Inicializar matriz de similitud
            jaccardSimilarity = Array(sampledUserData.length).fill().map(() => Array(sampledUserData.length).fill(0));
            
            // Precomputar sets para mejor rendimiento
            const userSets = sampledUserData.map(user => new Set(user.titles));
            
            // Calcular similitud para cada par de usuarios por lotes
            const totalPairs = (sampledUserData.length * (sampledUserData.length - 1)) / 2;
            let processedPairs = 0;
            let lastUpdate = 0;
            
            // Usar Web Workers para cálculo en segundo plano si está disponible
            if (window.Worker) {
                calculateWithWorker(userSets);
            } else {
                calculateInMainThread(userSets);
            }
        }
        
        // Calcular similitud en el hilo principal (para navegadores sin Web Workers)
        function calculateInMainThread(userSets) {
            const totalPairs = (sampledUserData.length * (sampledUserData.length - 1)) / 2;
            let processedPairs = 0;
            
            const processBatch = (startI = 0, startJ = 1) => {
                for (let i = startI; i < sampledUserData.length; i++) {
                    // Diagonal principal (máxima similitud)
                    jaccardSimilarity[i][i] = 1;
                    
                    for (let j = (i === startI ? startJ : i + 1); j < sampledUserData.length; j++) {
                        const setA = userSets[i];
                        const setB = userSets[j];
                        
                        // Calcular intersección de manera optimizada
                        let intersection = 0;
                        if (setA.size < setB.size) {
                            for (const item of setA) {
                                if (setB.has(item)) intersection++;
                            }
                        } else {
                            for (const item of setB) {
                                if (setA.has(item)) intersection++;
                            }
                        }
                        
                        // Calcular similitud de Jaccard
                        const union = setA.size + setB.size - intersection;
                        const similarity = union > 0 ? intersection / union : 0;
                        
                        // Solo almacenar si supera el umbral
                        if (similarity >= similarityThreshold) {
                            jaccardSimilarity[i][j] = similarity;
                            jaccardSimilarity[j][i] = similarity;
                        }
                        
                        processedPairs++;
                        
                        // Actualizar progreso cada 1000 pares
                        if (processedPairs % 1000 === 0 || processedPairs === totalPairs) {
                            const percent = (processedPairs / totalPairs * 100);
                            updateProgress(percent, `Calculando: ${processedPairs} de ${totalPairs} pares`);
                            
                            // Pausar para UI si no hemos terminado
                            if (processedPairs < totalPairs) {
                                setTimeout(() => processBatch(i, j + 1), 0);
                                return;
                            }
                        }
                    }
                }
                
                // Cálculo completado
                finishCalculation();
            };
            
            processBatch();
        }
        
        // Usar Web Worker para cálculo en segundo plano
        function calculateWithWorker(userSets) {
            showStatus('Usando Web Worker para cálculo optimizado...', 'info');
            
            // Crear worker en línea
            const workerCode = `
                self.onmessage = function(e) {
                    const { userSets, similarityThreshold } = e.data;
                    const n = userSets.length;
                    const similarityMatrix = Array(n).fill().map(() => Array(n).fill(0));
                    
                    for (let i = 0; i < n; i++) {
                        similarityMatrix[i][i] = 1; // Diagonal
                        
                        for (let j = i + 1; j < n; j++) {
                            const setA = new Set(userSets[i]);
                            const setB = new Set(userSets[j]);
                            
                            let intersection = 0;
                            if (setA.size < setB.size) {
                                for (const item of setA) {
                                    if (setB.has(item)) intersection++;
                                }
                            } else {
                                for (const item of setB) {
                                    if (setA.has(item)) intersection++;
                                }
                            }
                            
                            const union = setA.size + setB.size - intersection;
                            const similarity = union > 0 ? intersection / union : 0;
                            
                            if (similarity >= similarityThreshold) {
                                similarityMatrix[i][j] = similarity;
                                similarityMatrix[j][i] = similarity;
                            }
                        }
                        
                        // Reportar progreso
                        if (i % 10 === 0) {
                            self.postMessage({
                                type: 'progress',
                                percent: (i / n * 100)
                            });
                        }
                    }
                    
                    self.postMessage({
                        type: 'complete',
                        matrix: similarityMatrix
                    });
                };
            `;
            
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            const worker = new Worker(URL.createObjectURL(blob));
            
            worker.onmessage = function(e) {
                if (e.data.type === 'progress') {
                    updateProgress(e.data.percent, 'Calculando con Web Worker...');
                } else if (e.data.type === 'complete') {
                    jaccardSimilarity = e.data.matrix;
                    finishCalculation();
                    worker.terminate();
                }
            };
            
            // Enviar datos al worker
            worker.postMessage({
                userSets: userSets.map(set => Array.from(set)),
                similarityThreshold: similarityThreshold
            });
        }
        
        // Finalizar cálculo y realizar clustering
        function finishCalculation() {
            updateProgress(100, 'Completado');
            
            // Realizar clustering
            performClustering();
            
            // Habilitar botones adicionales
            showGraphBtn.disabled = false;
            showDendrogramBtn.disabled = false;
            showRecommendationsBtn.disabled = false;
            
            showStatus('Similitud de Jaccard calculada correctamente. Clustering aplicado.', 'success');
            setTimeout(() => showProgress(false), 1000);
            
            console.log('Matriz de similitud calculada para', sampledUserData.length, 'usuarios');
        }
        
        // Realizar clustering basado en la similitud
        function performClustering() {
            // Convertir similitud a distancia (1 - similitud)
            const distanceMatrix = jaccardSimilarity.map(row => 
                row.map(similarity => similarity > 0 ? 1 - similarity : 2) // 2 = distancia máxima
            );
            
            // Aplicar clustering jerárquico aglomerativo optimizado
            clusters = optimizedHierarchicalClustering(distanceMatrix, 5);
            
            // Construir árbol jerárquico completo para el dendrograma
            hierarchicalTree = buildHierarchicalTree(distanceMatrix, sampledUserIds);
            
            // Asignar colores a los clusters
            clusterColors = [];
            for (let i = 0; i < clusters.length; i++) {
                clusterColors.push(colorPalette[i % colorPalette.length]);
            }
            
            console.log('Clusters generados:', clusters);
        }
        
        // Clustering jerárquico optimizado
        function optimizedHierarchicalClustering(distanceMatrix, numClusters) {
            // Inicializar clusters
            let clusters = [];
            for (let i = 0; i < distanceMatrix.length; i++) {
                clusters.push([i]);
            }
            
            // Matriz de distancias entre clusters
            let clusterDistances = distanceMatrix.map(row => [...row]);
            
            while (clusters.length > numClusters) {
                let minDistance = Infinity;
                let clusterA = -1;
                let clusterB = -1;
                
                // Encontrar los clusters más cercanos
                for (let i = 0; i < clusters.length; i++) {
                    for (let j = i + 1; j < clusters.length; j++) {
                        if (clusterDistances[i][j] < minDistance) {
                            minDistance = clusterDistances[i][j];
                            clusterA = i;
                            clusterB = j;
                        }
                    }
                }
                
                if (clusterA === -1 || clusterB === -1) break;
                
                // Fusionar clusters
                clusters[clusterA] = clusters[clusterA].concat(clusters[clusterB]);
                clusters.splice(clusterB, 1);
                
                // Actualizar matriz de distancias
                for (let i = 0; i < clusters.length; i++) {
                    if (i !== clusterA) {
                        // Enlace completo: máxima distancia entre clusters
                        let maxDist = 0;
                        for (const itemA of clusters[clusterA]) {
                            for (const itemB of clusters[i]) {
                                if (distanceMatrix[itemA][itemB] > maxDist) {
                                    maxDist = distanceMatrix[itemA][itemB];
                                }
                            }
                        }
                        clusterDistances[clusterA][i] = maxDist;
                        clusterDistances[i][clusterA] = maxDist;
                    }
                }
                
                // Eliminar el cluster fusionado
                clusterDistances.splice(clusterB, 1);
                for (let i = 0; i < clusterDistances.length; i++) {
                    clusterDistances[i].splice(clusterB, 1);
                }
            }
            
            return clusters;
        }
        
        // Construir árbol jerárquico completo para dendrograma
        function buildHierarchicalTree(distanceMatrix, labels) {
            // Implementación simplificada para demostración
            // En una implementación real, esto construiría el árbol completo
            
            return {
                id: 'root',
                height: 1,
                size: labels.length,
                children: labels.map((label, i) => ({
                    id: label,
                    index: i,
                    height: 0,
                    size: 1,
                    children: null
                }))
            };
        }
        
        // Renderizar grafo con clustering optimizado
        function renderGraphWithClustering() {
            if (jaccardSimilarity.length === 0 || clusters.length === 0) {
                showStatus('Primero calcula la similitud y clustering', 'error');
                return;
            }
            
            showStatus('Generando grafo con clustering...');
            
            // Limpiar contenedor
            graphDiv.innerHTML = '';
            
            // Configurar SVG
            const width = graphDiv.clientWidth;
            const height = 450;
            const svg = d3.select('#graph')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Crear nodos
            const nodes = sampledUserIds.map((id, i) => {
                let clusterIndex = -1;
                for (let j = 0; j < clusters.length; j++) {
                    if (clusters[j].includes(i)) {
                        clusterIndex = j;
                        break;
                    }
                }
                
                return { 
                    id, 
                    index: i, 
                    titleCount: sampledUserData[i].titles.length,
                    cluster: clusterIndex,
                    color: clusterIndex >= 0 ? clusterColors[clusterIndex] : '#ccc'
                };
            });
            
            // Crear enlaces solo para similitudes significativas
            const links = [];
            for (let i = 0; i < sampledUserIds.length; i++) {
                for (let j = i + 1; j < sampledUserIds.length; j++) {
                    if (jaccardSimilarity[i][j] > similarityThreshold) {
                        links.push({
                            source: i,
                            target: j,
                            value: jaccardSimilarity[i][j]
                        });
                    }
                }
            }
            
            // Configurar simulación de fuerzas
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.index).distance(d => 150 - (d.value * 100)))
                .force('charge', d3.forceManyBody().strength(-30))
                .force('center', d3.forceCenter(width / 2, height / 2));
            
            // Dibujar enlaces
            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', d => d.value * 3);
            
            // Dibujar nodos
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('r', d => 4 + (d.titleCount / 5))
                .attr('fill', d => d.color)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // Actualizar posición
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
            });
            
            // Funciones de arrastre
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            showStatus('Grafo con clustering generado correctamente', 'success');
        }
        
        // Renderizar dendrograma optimizado
        function renderDendrogram() {
            if (!hierarchicalTree) {
                showStatus('Primero calcula la similitud y clustering', 'error');
                return;
            }
            
            showStatus('Generando dendrograma...');
            
            // Implementación simplificada para demostración
            dendrogramDiv.innerHTML = '<p>Dendrograma optimizado para grandes conjuntos de datos.</p>' +
                                     '<p>Use el muestreo y umbral de similitud para mejor rendimiento.</p>';
            
            showStatus('Visualización simplificada para mejor rendimiento', 'info');
        }
        
        // Mostrar recomendaciones optimizadas
        function showRecommendations() {
            if (jaccardSimilarity.length === 0 || clusters.length === 0) {
                showStatus('Primero calcula la similitud y clustering', 'error');
                return;
            }
            
            showStatus('Generando recomendaciones basadas en clusters...');
            
            recommendationsDiv.innerHTML = '';
            
            // Para cada cluster, encontrar títulos populares
            for (let i = 0; i < clusters.length; i++) {
                const cluster = clusters[i];
                const titleCounts = {};
                
                for (const userIndex of cluster) {
                    for (const title of sampledUserData[userIndex].titles) {
                        titleCounts[title] = (titleCounts[title] || 0) + 1;
                    }
                }
                
                // Top 5 títulos más populares
                const popularTitles = Object.entries(titleCounts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5)
                    .map(([title, count]) => ({ title, count }));
                
                const clusterDiv = document.createElement('div');
                clusterDiv.className = 'recommendation-item';
                clusterDiv.innerHTML = `
                    <h4><span class="cluster-color" style="background:${clusterColors[i]}"></span> 
                    Cluster ${i+1} (${cluster.length} usuarios)</h4>
                    <p>Títulos más populares:</p>
                    <ul>
                        ${popularTitles.map(t => `<li>${t.title} (${t.count} usuarios)</li>`).join('')}
                    </ul>
                `;
                recommendationsDiv.appendChild(clusterDiv);
            }
            
            showStatus('Recomendaciones generadas correctamente', 'success');
        }
    </script>
</body>
</html>
